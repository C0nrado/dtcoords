import inspect
from inspect import signature
from typing import get_args
from functools import wraps

from collections.abc import Sequence
from numpy import ndarray, datetime64
from pandas import Timestamp
from typing import Tuple, Union, Callable, Optional, Any, Generator, get_type_hints

Datetime = Union[datetime64, datetime.datetime, Timestamp]

def _check_valid_type(typ):
    """typechecker for Unions"""
    valid_classes = (datetime.datetime, np.datetime64, pd.Timestamp)
    valid_classes = typing.get_args(Datetime)
    try:
      return any(issubclass(class_item, valid_classes) for class_item in get_args(typ))
    except TypeError:
      return False

def datetime_kwargs_convertion(func: Callable) -> Callable:
    """decorator to do special treatments in datetime-like kw arguments."""

    def process_arguments(bargs):
        assert all(kw in bargs.kwargs for kw in ['ref' , 'unit']), "ref and unit must be passed."
        sel_annotated_params = {param: typ for param, typ in annots.items() if _check_valid_type(typ)}
        all_params = {**bargs.arguments, **bargs.kwargs}
        arguments = {param_name: (elapsed_time(value, ref=bargs.kwargs['ref'], unit=bargs.kwargs['unit'])
                                    if param_name in sel_annotated_params
                                    else value)
                      for param_name, value in all_params.items()}
        return sig.bind(**arguments)

    @wraps(func)
    def _decorated(*args, **kwargs) -> Any:
        bargs = sig.bind(*args, **kwargs)
        update_bargs = process_arguments(bargs)
        res = func(*update_bargs.args, **update_bargs.kwargs)
        return res
    
    sig = signature(func)
    annots = get_type_hints(func)
    
    return _decorated

def elapsed_time(current: Datetime, ref: Optional[Datetime], unit: str) -> float:
    """convert datetime-like data to number equivalent to the current elapsed time
    since `ref` in units of time.
    
    current : datetime64 | datetime | Timestamp
    ref : datetime64 | datetime | Timestamp
    unit: valid numpy timedelta64 unit. (default 'm')"""
    
    delta = np.datetime64(current) - np.datetime64(ref)
    delta = np.timedelta64(delta, unit)
    return delta.astype(float)

def cast_elapsed_time(elapsed_time: Scalar, ref: Optional[Datetime], unit='m') -> float:
    """restore date-like format from the end of and event which lived for
    `elapsed_time` since `ref`.
    
    elapsed_time : float | int
    ref : datetime64 | datetime | Timestamp
    unit: valid numpy timedelta64 unit. (default 'm')"""

    dt = np.datetime64(ref) + np.timedelta64(elapsed_time, unit)
    return dt